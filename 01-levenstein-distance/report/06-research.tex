\chapter{Исследовательский раздел}
Раздел содержит описание замера процессорного времени и оценку затрачиваемой    алгоритмом оперативной памяти.

\section{Замер процессорного времени}
Замер процессорного времени выполнен на микроконтроллере \textit{STM-32~Nucleo-144}.
Замер проведен с помощью функции \textit{process\_time} модуля \textit{time}. Исследовалась зависимость процессорного времени работы алгоритма от длины входных строк. Размер строк варьировался от 1 до 6 символов с шагом в один символ. Содержимое строк -- случайные последовательности символов заданной длины в кодировке \textit{UTF-8}. Длина строк в рамках замера совпадает. Для каждой длины замер проведен $N=10$ раз. В качестве результата выбрано среднее арифметическое из $N$ замеров.

В таблице~\ref{tbl:time} приведены результаты замера процессорного времени работы алгоритмов.

\begin{table}[ht]
	\small
	\begin{center}
			\caption{Результат замеров процессорного времени работы алгоритмов для строк с длиной от 1 до 10 символов.}
			\label{tbl:time}
			\begin{tabular}{|r|r|r|r|r|}
				\hline
				& \multicolumn{4}{c|}{\bfseries Время, мкс} \\ \cline{2-5}
				& \bfseries Левенштейн
				& \bfseries Итер. Д-Л 
				& \bfseries Рекур. Л 
				& \bfseries Рекур. с мемо Д-Л \\
				\hline
				\bfseries Длина, символ & & & & \\
				\hline
				1 & 0.102485 & 0.101186 & 0.088565 & 0.386414 \\
				\hline
				2 & 0.172556 & 0.183024 & 0.424275 & 1.047953 \\
				\hline
				3 & 0.348513 & 0.354702 & 2.049482 & 2.956012 \\
				\hline
				4 & 0.561802 & 0.670172 & 10.499670 & 4.002789 \\
				\hline
				5 & 0.715580 & 1.031140 & 57.425976 & 6.211656 \\
				\hline
				6 & 1.115551 & 1.244014 & 291.462974 & 10.310614 \\
				\hline
			\end{tabular}
	\end{center}
\end{table}

\clearpage

На рисунке~\ref{img:bench-graph.pdf} табличные данные отображены графически.

\includeimage
{bench-graph.pdf} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1 \textwidth} % Ширина рисунка
{Зависимость процессорного времени работы алгоритма от длины входных строк} % Подпись рисунка

\clearpage

\section{Оценка затраченной оперативной памяти}

\subsection{Алгоритм Левенштейна}
На хранение локальных переменных длин строк $S_1$, $S_2$ и параметра $delta$ затрачено $3~\cdot sizeof(int)$ байт. Для хранения матрицы значений $D(i,j)$ затрачено $(sizeof(S_1) + 1) \cdot (sizeof(S_2) + 1) \cdot sizeof(int)$. Итоговый объем памяти выражен формулой~(\ref{eq:levsize}).
\begin{equation}
    \label{eq:levsize}
    (sizeof(S_1) + 1) \cdot (sizeof(S_2) + 1) \cdot sizeof(int) + 3 \cdot sizeof(int)
\end{equation}

\subsection{Алгоритм Дамерау~---~Левенштейна}
На хранение локальных переменных длин строк $S_1$, $S_2$ и параметра $delta$ затрачено $3~\cdot sizeof(int)$ байт. Для хранения матрицы значений $D(i,j)$ затрачено $(sizeof(S_1) + 1) \cdot (sizeof(S_2) + 1) \cdot sizeof(int)$. Дополнительно, для учета перестановок символов, затраты на память остаются аналогичными. Итоговый объем памяти выражен формулой~(\ref{eq:dlevsize}).
\begin{equation}
    \label{eq:dlevsize}
    (sizeof(S_1) + 1) \cdot (sizeof(S_2) + 1) \cdot sizeof(int) + 3 \cdot sizeof(int)
\end{equation}

\subsection{Рекурсивный алгоритм Левенштейна}
Для рекурсивного алгоритма на каждом уровне рекурсии затрачивается память на хранение локальных переменных длин строк $S_1$, $S_2$ и параметра $delta$, что составляет $3 \cdot sizeof(int)$ байт. Также на каждом уровне создаются новые строки, что в худшем случае требует $sizeof(S_1) + sizeof(S_2)$ памяти на каждом уровне рекурсии. Глубина рекурсии в худшем случае будет $sizeof(S_1)~\cdot~sizeof(S_2)$, что дает итоговый объем памяти, выраженный формулой~(\ref{eq:recL}).

\begin{equation}
\begin{split}
\label{eq:recL}
    (sizeof(S_1) + sizeof(S_2)) \cdot sizeof(int) \cdot (sizeof(S_1) \cdot sizeof(S_2)) + \\
    3 \cdot sizeof(int) \cdot (sizeof(S_1) \cdot sizeof(S_2))
\end{split}
\end{equation}

\subsection{Алгоритм Дамерау~---~Левенштейна с кешем}

Для хранения локальных переменных длин строк $S_1$, $S_2$, параметра $delta$ и хеш-таблицы (мемоизация) затрачивается $3 \cdot sizeof(int)$ байт. Объем памяти, необходимый для хранения всех возможных промежуточных результатов, составляет $sizeof(S_1) \cdot sizeof(S_2) \cdot sizeof(int)$ для хранения ключей и значений хеш-таблицы. Итоговый объем памяти выражен формулой~(\ref{eq:memsize}).
\begin{equation}
    \label{eq:memsize}
    (sizeof(S_1) \cdot sizeof(S_2) \cdot sizeof(int)) + 3 \cdot sizeof(int)
\end{equation}

\clearpage

\section*{Вывод}

Алгоритмы Левенштейна и Дамерау~---~Левенштейна имеют схожую производительность как по памяти, так и по времени работы. Выбор алгоритма стоит делать опираясь на то, нужно ли учитывать транспозицию символов в решаемой задаче. Рекурсивная реализация алгоритма Левенштейна имеет худшее время работы. Стоит отметить, что такая реализация имеет аппаратное ограничение, так как ввод длинных строк может привести к переполнению стека из-за рекурсивного спуска. Наиболее оптимальным по времени и памяти оказался алгоритм Дамерау~---~Левенштейна с кешированием. Рекурсия обеспечивает малое количество затрачиваемой памяти, а мемоизация сокращает количество повторных вычислений. В отсутствие нехватки вычислительных мощностей предпочтение стоит отдать именно этой реализации.